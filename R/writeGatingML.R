#############################################
## Code related to writing Gating-ML files ##
#############################################

write.gatingML <- function(flowEnv, file = NULL)
{
    # TODO Drop this note when done.
    cat("Please do not use this function, it is currently under development!!\n--------------------------------------------------------------------\n\n")
    
    if(!is.null(file) && !is(file, "character")) 
        stop("A file has to be either NULL or a character string.", call. = FALSE)
    if(is.null(flowEnv) || !is.environment(flowEnv))
        stop("A flowEnv environment with objects to be saved is requred.", call. = FALSE)
    if(!is.null(file) && substr(file, nchar(file) - 3, nchar(file)) != ".xml")
        file <- paste(file, "xml", sep=".")

    namespaces <- c(
        "gating" = "http://www.isac-net.org/std/Gating-ML/v2.0/gating", 
        "xsi" = "http://www.w3.org/2001/XMLSchema-instance", 
        "transforms" = "http://www.isac-net.org/std/Gating-ML/v2.0/transformations", 
        "data-type" = "http://www.isac-net.org/std/Gating-ML/v2.0/datatypes")
    
    gatingMLNode = suppressWarnings(xmlTree("gating:Gating-ML", namespaces = namespaces, 
        attrs = c("xsi:schemaLocation" = "http://www.isac-net.org/std/Gating-ML/v2.0/gating http://flowcyt.sourceforge.net/gating/2.0/xsd/Gating-ML.v2.0.xsd http://www.isac-net.org/std/Gating-ML/v2.0/transformations http://flowcyt.sourceforge.net/gating/2.0/xsd/Transformations.v2.0.xsd http://www.isac-net.org/std/Gating-ML/v2.0/datatypes http://flowcyt.sourceforge.net/gating/2.0/xsd/DataTypes.v2.0.xsd")))

    gatingMLNode$addNode("data-type:custom_info", close = FALSE)
    gatingMLNode$addNode("info", "Gating-ML 2.0 export generated by R/flowUtils/flowCore")
    gatingMLNode$addNode("R-version", sessionInfo()$R.version$version.string)
    gatingMLNode$addNode("flowCore-version", as.character(packageVersion("flowCore")))
    gatingMLNode$addNode("flowUtils-version", as.character(packageVersion("flowUtils")))
    gatingMLNode$addNode("XML-version", as.character(packageVersion("XML")))
    gatingMLNode$closeTag()
    
    for (x in ls(flowEnv)) 
    { 
        switch(class(flowEnv[[x]]),
            "rectangleGate" = addRectangleGateNode(gatingMLNode, x, flowEnv),
            "polygonGate" = addPolygonGateNode(gatingMLNode, x, flowEnv),
            "ellipsoidGate" = addEllipsoidGateNode(gatingMLNode, x, flowEnv),
			"intersectFilter" = addBooleanAndGateNode(gatingMLNode, x, flowEnv),
			"unionFilter" = addBooleanOrGateNode(gatingMLNode, x, flowEnv),
			"complementFilter" = addBooleanNotGateNode(gatingMLNode, x, flowEnv),
			"compensatedParameter" = ignore(),
			"numeric" = ignore(),
            cat(paste("!", x, ": class", class(flowEnv[[x]]), "- not supported yet.\n"))
			# TODO Add quadGate support
        )
    }
    
    if(!is.null(file)) sink(file = file)
    cat(saveXML(gatingMLNode$value(), encoding = "UTF-8"))
	if(!is.null(file)) sink()
}

addRectangleGateNode <- function(gatingMLNode, x, flowEnv)
{
	cat(paste("- Working on ", x, ".\n", sep=""))
    gate = flowEnv[[x]]
    attrs = c("gating:id" = filterIdtoXMLId(gate@filterId))
    gatingMLNode$addNode("gating:RectangleGate", attrs = attrs, close = FALSE)
    addDimensions(gatingMLNode, x, flowEnv)
    gatingMLNode$closeTag() # </gating:RectangleGate>
}

addPolygonGateNode <- function(gatingMLNode, x, flowEnv)
{
	cat(paste("- Working on ", x, ".\n", sep=""))
    gate = flowEnv[[x]]
    attrs = c("gating:id" = filterIdtoXMLId(gate@filterId))
    gatingMLNode$addNode("gating:PolygonGate", attrs = attrs, close = FALSE)
    addDimensions(gatingMLNode, x, flowEnv)
    for (i in 1:length(gate@boundaries[,1]))
    {
        gatingMLNode$addNode("gating:vertex", close = FALSE)
        attrs = c("data-type:value" = gate@boundaries[i,1])
        gatingMLNode$addNode("gating:coordinate", attrs = attrs)
        attrs = c("data-type:value" = gate@boundaries[i,2])
        gatingMLNode$addNode("gating:coordinate", attrs = attrs)
        gatingMLNode$closeTag() # </gating:vertex>
    }
    gatingMLNode$closeTag() # </gating:PolygonGate>
}

addEllipsoidGateNode <- function(gatingMLNode, x, flowEnv)
{
	cat(paste("- Working on ", x, ".\n", sep=""))
	gate = flowEnv[[x]]
    attrs = c("gating:id" = filterIdtoXMLId(gate@filterId))
    gatingMLNode$addNode("gating:EllipsoidGate", attrs = attrs, close = FALSE)
    addDimensions(gatingMLNode, x, flowEnv)
	
	gatingMLNode$addNode("gating:mean", close = FALSE)
	for (i in 1:length(gate@mean))
	{
		attrs = c("data-type:value" = as.numeric(gate@mean[i]))
		gatingMLNode$addNode("gating:coordinate", attrs = attrs)
	}
	gatingMLNode$closeTag() # </gating:mean>
	
	gatingMLNode$addNode("gating:covarianceMatrix", close = FALSE)
	for (row in 1:length(gate@cov[,1]))
	{
		gatingMLNode$addNode("gating:row", close = FALSE)
		for (column in 1:length(gate@cov[1,]))
		{
			attrs = c("data-type:value" = gate@cov[row,column])
			gatingMLNode$addNode("gating:entry", attrs = attrs)
		}
		gatingMLNode$closeTag() # </gating:row>
	}
	gatingMLNode$closeTag() # </gating:covarianceMatrix>
	
	attrs = c("data-type:value" = gate@distance)
	gatingMLNode$addNode("gating:distanceSquare", attrs = attrs)
	
    gatingMLNode$closeTag() # </gating:EllipsoidGate>
}

addBooleanAndGateNode <- function(gatingMLNode, x, flowEnv)
{
	cat(paste("- Working on ", x, ".\n", sep=""))
	gate = flowEnv[[x]]
	attrs = c("gating:id" = filterIdtoXMLId(gate@filterId))
	gatingMLNode$addNode("gating:BooleanGate", attrs = attrs, close = FALSE)
	gatingMLNode$addNode("gating:and", close = FALSE)
	for (i in 1:length(gate@filters))
	{
		attrs = c("gating:ref" = filterIdtoXMLId(gate@filters[[i]]@filterId))
		gatingMLNode$addNode("gating:gateReference", attrs = attrs)
	}
	if(length(gate@filters)  == 1) 
	{
		# If there was just one referenced filter than we add it twice
		# since and/or gates require at least two arguments in Gating-ML 2.0
		gatingMLNode$addNode("gating:gateReference", attrs = attrs)
	} 
	gatingMLNode$closeTag() # </gating:and>
	gatingMLNode$closeTag() # </gating:BooleanGate>	
}

addBooleanOrGateNode <- function(gatingMLNode, x, flowEnv)
{
	cat(paste("- Working on ", x, ".\n", sep=""))
	gate = flowEnv[[x]]
	attrs = c("gating:id" = filterIdtoXMLId(gate@filterId))
	gatingMLNode$addNode("gating:BooleanGate", attrs = attrs, close = FALSE)
	gatingMLNode$addNode("gating:or", close = FALSE)
	for (i in 1:length(gate@filters))
	{
		attrs = c("gating:ref" = filterIdtoXMLId(gate@filters[[i]]@filterId))
		gatingMLNode$addNode("gating:gateReference", attrs = attrs)
	}
	if(length(gate@filters)  == 1) 
	{
		# If there was just one referenced filter than we add it twice
		# since and/or gates require at least two arguments in Gating-ML 2.0
		gatingMLNode$addNode("gating:gateReference", attrs = attrs)
	} 
	gatingMLNode$closeTag() # </gating:or>
	gatingMLNode$closeTag() # </gating:BooleanGate>	
}
#TODO Check errors for Boolean gates not having enough pars. 
addBooleanNotGateNode <- function(gatingMLNode, x, flowEnv)
{
	cat(paste("- Working on ", x, ".\n", sep=""))
	gate = flowEnv[[x]]
	attrs = c("gating:id" = filterIdtoXMLId(gate@filterId))
	gatingMLNode$addNode("gating:BooleanGate", attrs = attrs, close = FALSE)
	gatingMLNode$addNode("gating:not", close = FALSE)
	if(length(gate@filters)  == 1) 
	{
		attrs = c("gating:ref" = filterIdtoXMLId(gate@filters[[1]]@filterId))
		gatingMLNode$addNode("gating:gateReference", attrs = attrs)
	}
	gatingMLNode$closeTag() # </gating:or>
	gatingMLNode$closeTag() # </gating:BooleanGate>	
}

addDimensions <- function(gatingMLNode, x, flowEnv)
{
    for (i in 1:length(flowEnv[[x]]@parameters))
    {
        attrs = c()
        parameter = flowEnv[[x]]@parameters[[i]]

        if (is(flowEnv[[x]], "rectangleGate"))
        {
            # TODO Refactor this piece of code?
            min = flowEnv[[x]]@min[[i]]
            max = flowEnv[[x]]@max[[i]]
            if(min != -Inf) attrs = c(attrs, "gating:min" = min)
            if(max != Inf) attrs = c(attrs, "gating:max" = max)
        }

        if(is(parameter, "transformReference")) parameter = resolveTransformationReference(parameter)
        if(is(parameter, "unitytransform")) attrs = c(attrs, "gating:compensation-ref" = "uncompensated")
        else if(is(parameter, "singleParameterTransform"))
        {
            attrs = c(attrs, "gating:transformation-ref" = parameter@transformationId)
            parameter = parameter@parameters
            if(is(parameter, "transformReference")) parameter = resolveTransformationReference(parameter)
            
            if(is(parameter, "unitytransform")) attrs = c(attrs, "gating:compensation-ref" = "uncompensated")
            else if(is(parameter, "compensatedParameter"))
            {
                if (parameter@spillRefId != "SpillFromFCS")
                    attrs = c(attrs, "gating:compensation-ref" = filterIdtoXMLId(parameter@spillRefId))
                else 
                    attrs = c(attrs, "gating:compensation-ref" = "FCS")
            }
            
        } 
        else if(is(parameter, "compensatedParameter"))
        {
            if (parameter@spillRefId != "SpillFromFCS")
                attrs = c(attrs, "gating:compensation-ref" = filterIdtoXMLId(parameter@spillRefId))
            else 
                attrs = c(attrs, "gating:compensation-ref" = "FCS")
        } 
        else
        {
            cat(paste("This should not happen; unexpected parameter class", class(parameter))) # TODO
            if(is(parameter, "transformReference")) parameter = resolveTransformationReference(parameter)
        }
        
        gatingMLNode$addNode("gating:dimension", attrs = attrs, close = FALSE)
        addDimensionContents(gatingMLNode, parameter, flowEnv)
        gatingMLNode$closeTag() # </gating:dimension>
        
    }
}

addDimensionContents <- function(gatingMLNode, parameter, flowEnv)
{
    if(is(parameter, "compensatedParameter")) 
    {
        if (parameter@spillRefId == "SpillFromFCS") 
            attrs = c("data-type:name" = parameter@parameters)
        else 
            attrs = c("data-type:name" = parameter@transformationId)
    }
    else if(is(parameter, "unitytransform")) attrs = c("data-type:name" = parameter@parameters)
    else if(is(parameter, "character")) attrs = c("data-type:name" = parameter)
    else {
        cat("\nThis should not happen!\n\n") # TODO
        attrs = c("data-type:name" = "????")
    }
    gatingMLNode$addNode("data-type:fcs-dimension", attrs = attrs)
}

filterIdtoXMLId <- function(x)
{
    # TODO figure out something safe
    x
}

resolveTransformationReference <- function(trRef)
{
    if(!is(trRef, "transformReference")) 
        stop(paste("Cannot call resolveTransformationReference on", class(trRef)))
    if(exists(trRef@transformationId, envir=trRef@searchEnv))
        trRef@searchEnv[[trRef@transformationId]]
    else
        stop(paste("Cannot find", trRef@transformationId, "in the environment."))
}

ignore <- function()
{
	NA
}