% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
%\VignetteIndexEntry{Gating-ML support in R}
%\VignetteDepends{flowUtils,flowCore,gatingMLData}
%\VignetteKeywords{Gating-ML}
%\VignettePackage{flowUtils}
\documentclass[11pt]{article}

\usepackage{times}
\usepackage{hyperref}
\usepackage[authoryear,round]{natbib}
\usepackage{times}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{subfigure}

\textwidth=6.2in
\textheight=8.5in
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

\title{flowUtils: Gating-ML Support in Flow Cytometry}
\author{Josef Spidlen}

\begin{document}
\maketitle

\begin{abstract}
\noindent 
Gating in flow cytometry is a highly important process for selecting
populations of interests by defining the characteristics of particles 
for further data acquisition or analysis. Gating-ML represents 
a specification on how to form unambiguous 
XML-based gate definitions. Such a description of gates facilitates
the interchange and validation of data and analysis between different
software packages with the potential for significant increase of 
hardware and software interoperability.\\

\noindent The \Rpackage{flowUtils} package supports reading of Gating-ML 
version 1.5, and both, reading and writing of Gating-ML 2.0. 
Gating-ML 2.0 is currently (December 2013) the latest version 
of Gating-ML.\\

\noindent \textbf{Keywords:} Flow cytometry, gating, XML, data standard
\end{abstract}

<<loadPackage, echo=FALSE, results=hide>>=
library(flowUtils)
options(width=60)
@

\section{Introduction}
\subsection{Background}
Gating in flow cytometry is a highly important process for selecting
populations of interests by defining the characteristics of particles 
for further data acquisition or analysis. A gate is a filter (set of
boundaries) that serve to isolate a specific group of cytometric 
events (e.g. cells) from a larger set. A standard formal way of 
exchanging unambiguous descriptions of gates is crucial for 
interoperability among analytical hardware and software applications.\\

Gating-ML represents a specification on how to form unambiguous 
XML-based gate definitions. Such a description of gates facilitates
the interchange and validation of data and analysis between different
software packages with the potential for significant increase of 
hardware and software interoperability. 

\subsection{Gating-ML 1.5}
Gating-ML has undergone several revisions since the first public 
release in February 2006. In January 2008, Gating-ML version
1.5 \citep{paper:GatingML1.5} 
became an International Society for Advancement of Cytometry (ISAC)
Candidate Recommendation.
Gating-ML 1.5 supports rectangular gates in $n$ dimensions
(i.e., from one--dimensional range gates up to n--dimensional
hyper-rectangular regions), polygon gates in two (and more) dimensions,
ellipsoid gates in $n$ dimensions, decision tree structures, and 
Boolean collections of any of the types of gates. Gates are 
uniquely identified and may be ordered into a hierarchical structure 
to describe a gating strategy. Gates may be applied on parameters
(\textit{i.e.}, dimensions) as in list mode data files (\textit{e.g.}, FCS
files) or on transformed parameters as described by a data transformation.
Supported transformations include logarithmic, polynomial of degree one 
(\textit{i.e.}, linear combination with translation), square root, asinh
(inverse hyperbolic sin), split-scale, Hyperlog, and ratio of two 
parameters, as well as inverse transformations wherever these exist, 
\textit{i.e.}, exponential, quadratic transformation, hyperbolic sin, 
inverse split scale, and EH transformations, and compensation.
Arbitrary compound transformations may be created. Gates are 
applicable on raw ``channel'' values of the list mode data
files unless transformations are explicitely specified. 

\subsection{Gating-ML 2.0}
Based on feedback gathered from the implementors and development 
in the field, Gating-ML version 2.0 \citep{spec:GatingML2.0} has been developed
and adoped as a candidate for an ISAC Recommendation in January 2013. 
Gating-ML 2.0 significantly simplifies several aspects of Gating-ML 
by focusing on gates, data transformations and workflows that are 
useful in flow cytometry, rather than asking implementors to 
support a very generic approach.
Gating-ML 2.0 supports rectangular gates in $n$ dimensions 
(\textit{i.e.}, from one-dimensional range gates up to $n$-dimensional 
hyper-rectangular regions), quadrant gates in $n$ dimensions, polygon 
gates, ellipsoid gates in $n$ dimensions, and Boolean collections of 
any of the types of gates. Supported gate types have been selected 
based on feedback on Gating-ML 1.5 in order to keep the specification
simple while accommodate future innovations in automated 
multidimensional gating and clustering in a generic way.
Gates are uniquely identified and may be ordered
into a hierarchical structure to describe a gating strategy.
Gates may be applied on list mode data files (\textit{e.g.}, FCS files), 
which may be transformed as explicitly described. Gating-ML 2.0 
specification supports open transformations (i.e., published and 
free to use) which have been shown useful for display or 
analysis of cytometry data, such as Logicle and Hyperlog. 
In addition, transformations such as linear, logarithmic, 
and inverse hyperbolic sine are supported and have been extended 
to allow for additional parameterization and tweaking specifically 
for the display of flow cytometry data. In Gating-ML 2.0, these 
extensions are called FLin, FLog and FASinH, respectively. Finally, a
parametrized ratio of two FCS dimensions (i.e., FRatio) and fluorescence 
compensation complete the list of supported transformations.
Compared to Gating-ML 1.5, the list of Gating-ML 2.0 supported
transformations has been shortened by omitting transformations 
that have not been found particularly useful or are no longer
necessary due to additional design changes. In addition, values from 
FCS files are referenced as scale ``values'' (used to be channel 
values in Gating-ML 1.5), which eliminates the necessity to encode the ``channel
to scale'' transformation in Gating-ML (this transformation is unambiguously
captured by keywords in the FCS data file standard). Finally, Gating-ML 2.0 
no longer supports compound transformations in general. Instead, each gate 
dimension can be defined referencing up to one ``scale'' transformation 
plus an optional fluorescence compensation description applied on an FCS
dimension, which may be an FCS dimension from a list mode data file,
or the result of an additional transformation, i.e., the ratio of two FCS
dimensions. All these changes have been made based on community feedback
in order to significantly simplify the Gating-ML specification, 
especially for Gating-ML consumers (readers).

\subsection{Gating-ML support in flowUtils}
The \Rpackage{flowUtils} package supports reading of Gating-ML 
version 1.5 (implemented by N. Gopalakrishnan in 2008), and both
reading and writing of Gating-ML 2.0 (implemented by J. Spidlen in
2013). Gating-ML 2.0 is currently (as of December 2013) the latest version
of Gating-ML.

\section{Reading, applying and writing Gating-ML files}
\subsection{Reading Gating-ML files}
Any Gating-ML 1.5 or Gating-ML 2.0 compliant XML file can be read by the
\Rfunction{read.gatingML} function. This function requires an input 
file name and an environment to save objects parsed from the Gating-ML file. 

<<ReadGatingML1, echo=TRUE, results=verbatim>>=
gateFile <- system.file("extdata", "GatingML2.0_Example1.xml", 
    package = "flowUtils")
flowEnv  <- new.env()
read.gatingML(gateFile, flowEnv)
for (x in ls(flowEnv)) 
    if (is(flowEnv[[x]], "filter"))
        cat(paste("Gate", x, "of class", class(flowEnv[[x]]), "\n"))
@

Additional Gating-ML file examples are included with
the Gating-ML specifications as well as in the
\Rpackage{gatingMLData} package under
\texttt{extdata/Gating-MLFiles} (for Gating-ML 1.5) and under 
\texttt{extdata/Gml2/Gating-MLFiles} (for Gating-ML 2.0).
You can read these files using the following code:
<<ReadGatingML2, echo=TRUE, results=hide>>=
flowEnv1.5  <- new.env()
g1.5Example <- system.file("extdata/Gating-MLFiles", "01Rectangular.xml",
  package="gatingMLData")
read.gatingML(g1.5Example, flowEnv1.5)
ls(flowEnv1.5)

flowEnv2.0  <- new.env()
g2.0Example <- system.file("extdata/Gml2/Gating-MLFiles",
  "gates3.xml", package = "gatingMLData")
read.gatingML(g2.0Example, flowEnv2.0)
ls(flowEnv2.0)
@

We are not showing the output the \texttt{ls} commands since these contain over
a 100 of different objects saved in the environments, including various gates 
(data filters) and transformations (scale transformations, compensation, etc.).
Users are encouraged to explore these objects further. For example, if we
type
<<ReadGatingML3, echo=TRUE, results=verbatim>>=
flowEnv2.0[['myRectangleGate4LogicleArcSinHFCSCompensated']]
@
then we can see that \texttt{myRectangleGate4LogicleArcSinHFCSCompensated} is a
rectangular gate. Let us use the \texttt{str} command to explore the details
of this gate. 
<<ReadGatingML3, echo=TRUE, results=verbatim>>=
str(flowEnv2.0[['myRectangleGate4LogicleArcSinHFCSCompensated']])
@

TODO: other objects created, transformations applied to FCS parameters vs. any

\subsection{Applying Gating-ML files}
\label{sec:ApplyingGatingMLfiles}
Once the elements from a Gating-ML file are saved in an environment, the
``filters'' can be used to gate an FCS data file (\textit{i.e.,} a 
\Robject{flowFrame}), or a set of FCS files (\textit{i.e.,} a
\Robject{flowSet}).\\

Please pay attention to the \texttt{transformation} argument when
reading the FCS files. Gating-ML 1.5 specifies that data shall be used as
channel values by default, and any additional transformation shall be
explicitely specified in the Gating-ML 1.5 file. Therefore, you will need to
prevent R from applying the default ``channel-to-scale'' transformation when
reading your data with the intention of applying a Gating-ML 1.5 file to it.
This can be done by specifying \texttt{transformation=FALSE} in the 
\Rfunction{read.FCS} or \Rfunction{read.flowSet} functions. 

Gating-ML 2.0 specifies that data shall be used as scale values by default.
This means that the ``channel-to-scale'' transformation (as defined by the
keywords within the FCS data file) shell be applied prior applying
any additional scaling transformations described in the Gating-ML 2.0 file. 
Therefore, you should specify \texttt{transformation=linearize-with-PnG-scaling}
in the \Rfunction{read.FCS} or \Rfunction{read.flowSet} functions if
you will be working with Gating-ML 2.0 files.
An example of applying a Gating-ML 2.0 file on an FCS file is shown bellow:

<<ApplyGatingML1, echo=TRUE, results=verbatim>>=
fcsFile <- system.file("extdata/Gml2/FCSFiles", "data1.fcs", 
    package = "gatingMLData")
myFrame <- read.FCS(fcsFile, transformation="linearize-with-PnG-scaling")
for (x in ls(flowEnv)) if (is(flowEnv[[x]], "filter")) {
    result <- filter(myFrame, flowEnv[[x]])
    print(summary(result))
}
@

\subsection{Writing Gating-ML files}
\label{sec:WritingGatingML}
Gating-ML 2.0 compatible objects stored in an environment may be
written to a Gating-ML 2.0 file using the \Rfunction{write.gatingML}
function. Please see table \ref{tab:gatingMLClasses} for details about Gating-ML
compatible objects. These objects may have been created by a previous
\Rfunction{read.gatingML} call, or in any other way. A simple example of
manually creating a rectangular gate and saving the result in Gating-ML 2.0 is
shown below.

<<WriteGatingML1, echo=TRUE, eval=TRUE, results=hide>>=
flowEnv <- new.env()
flowEnv[['myGate']] <- rectangleGate(filterId="myGate", 
    list("FSC-H"=c(150, 300), "SSC-H"=c(200, 600)))
outputFile <- tempfile(fileext=".gating-ml2.xml")
write.gatingML(flowEnv, outputFile)
@

The second argument of the \Rfunction{write.gatingML} function (\textit{i.e.},
the filename is optional. The output is written to standard output if filename
is not provided.

Table \ref{tab:gatingMLClasses} summarizes what R classes are used to
capture various Gating-ML concepts (\textit{i.e.,} gates, transformations,
compensation, etc.). 
Corresponding \Rpackage{flowCore} filters and transformations are
created when Gating-ML 1.5 or 2.0 is read, and the same types of
filters and transformations can be saved in Gating-ML 2.0 as long as they are
Gating-ML 2.0 compatible and the
``workflow'' is expressible in Gating-ML 2.0 (see below).
Data driven filters (\textit{e.g.}, \Rclass{norm2Filter}, 
\Rclass{kmeansFilter}, etc.) are not supported by Gating-ML. 

\begin{table}
\caption{Summary of Gating-ML concepts and related R classes}
\label{tab:gatingMLClasses}
\centering
\begin{tabular}{| l | l | l | } 
\hline                        
\textbf{Gating-ML concept} & \textbf{R Class} & \textbf{Gating-ML version} \\ \hline
RectangleGate & rectangleGate & 1.5, 2.0 \\ \hline
Quadrant & rectangleGate (read), quadGate (write)$^{*}$ & 2.0 \\ \hline
PolygonGate & polygonGate & 1.5, 2.0 \\ \hline
EllipsoidGate & ellipsoidGate & 1.5, 2.0 \\ \hline
Boolean ``or'' gate & unionFilter & 1.5, 2.0 \\ \hline
Boolean ``and'' gate & intersectFilter & 1.5, 2.0 \\ \hline
Boolean ``not'' gate & complementFilter & 1.5, 2.0 \\ \hline
Gate with a parent & subsetFilter & 1.5, 2.0 \\ \hline
PolytopeGate & polytopeGate & 1.5 \\ \hline
DecisionTreeGate & expressionFilter & 1.5 \\ \hline
Referenced gate & filterReference & 1.5, 2.0 \\ \hline
flin & lintGml2 & 2.0 \\ \hline
flog & logtGml2 & 2.0 \\ \hline
fasinh & asinhtGml2 & 2.0 \\ \hline
logicle & logicletGml2 & 2.0 \\ \hline
hyperlog & hyperlog (v 1.5), hyperlogtGml2 (v 2.0) & 1.5, 2.0 \\ \hline
fratio & ratiotGml2 & 2.0 \\ \hline
dg1polynomial & dg1polynomial & 1.5 \\ \hline
ratio & ratio & 1.5 (2.0$^{**}$) \\ \hline
quadratic & quadratic & 1.5 \\ \hline
sqrt & squareroot & 1.5 \\ \hline
ln & logarithm & 1.5 \\ \hline
exponential & exponential & 1.5 \\ \hline
asinh & asinht & 1.5 (2.0$^{**}$) \\ \hline
sinh & sinht & 1.5 \\ \hline
EH & EHtrans & 1.5 \\ \hline
split-scale & splitscale & 1.5 \\ \hline 
inverse-split-scale & invsplitscale & 1.5 \\ \hline
spilloverMatrix & compensation, compensatedParameter & 1.5 \\ \hline
spectrumMatrix & compensation, compensatedParameter & 2.0 \\ \hline
\multicolumn{3}{p{15cm}}{\vspace{1pt}$^{*}$ The Quadrant gate in Gating-ML 2.0
allows for arbitrary splits of $n$-dimensional space, including more than one ``cut'' per dimension, and
with the option of merging several of these ``cuts'' into a resulting quadrant.
The quadGate filter in R is a less flexible structure implementing the
traditional two-dimensional quadrant gate concept (\textit{i.e., } with each 
dimension split exactly once, and always resulting in 4 quadrants).
Therefore, a quadGate filter is saved as a Quadrant gate in Gating-ML,
however, if a Quadrant gate is read from Gating-ML, then a set of
appropriate rectangleGate filters is created.} \\
\multicolumn{3}{p{15cm}}{$^{**}$ For Gating-ML 2.0 output, the ratio and asinht
transformations from Gating-ML 1.5 will be converted to fratio and fasinh,
respectively.} \\
\end{tabular}
\end{table}

R is a powerful language allowing you to create and combine various data
transformations and use these as dimensions (parameters) for your FCS data
filters. However, Gating-ML 2.0 supports only the ``workflows'' that are
considered meaningful for static gate based analysis of flow cytometry data.
This design decision has been made in order to make Gating-ML 2.0 implementation feasible for
common flow cytometry data analysis tools. In practice, Gating-ML 2.0
compatible workflows consist of the following steps:
\begin{enumerate}
\item Read the FCS data file and apply the ``channel to scale'' transformations
to FCS parameters as specified by the \$P$n$E and \$P$n$G keywords. (These
transformations are not explicitely described in Gating-ML.)
\item Optionally apply compensation based on either a compensation
description in the FCS data file (\textit{e.g.}, the \texttt{\$SPILLOVER},
\texttt{SPILL} or other keywords), or based on a ``spectrum'' matrix described
in the Gating-ML 2.0 file. A spectrum matrix covers both, the traditional
compensation based on square spillover matrices, as well as spectral unmixing,
see \citep{spec:GatingML2.0}.
\item For next steps, use either FCS parameters, or a ``fratio'' of two
FCS parameters (``fratio'' in Gating-ML 2.0 is an extended ratio of two
FCS parameters defined as $A\frac{x-B}{y-C}$, where $x,y$ are FCS parameters,
A, B, and C are some real constants.)
\item Optionally apply one of the Gating-ML 2.0 compatible scale
transformation, \textit{i.e.,} parameterized linear, log, asinh, Logicle or Hyperlog.
\item Apply Gating-ML 2.0 compatible gates in the data space created by previous
steps. Gating-ML 2.0 supported gate types include range gates, rectangular and
hyperrectangular gates, polygon gates, ellipsoid gates, quadrant gates and
Boolean collections (\textit{or--union}, \textit{and--intersect} and
\textit{not--complement}) of any of the gate types.
\end{enumerate}

Above, we have shown how a rectangular gate based on the FSC-H and SSC-H
parameters can be written to a Gating-ML 2.0 file. Another small example below
demonstrates the inclusion of compensation.  

<<WriteGatingML2, echo=TRUE, eval=TRUE, results=hide>>=
flowEnv <- new.env()
covM <- matrix(c(62.5, 37.5, 37.5, 62.5), nrow = 2, byrow=TRUE)
colnames(covM) <- c("FL1-H", "FL2-H")
myEl <- ellipsoidGate(mean=c(12, 16), distance=1, .gate=covM, filterId="myEl")
compPars <- list(
  compensatedParameter(parameters="FL1-H", spillRefId="SpillFromFCS", 
    transformationId=paste("FL1-H", "_compensated_according_to_FCS", sep=""), 
    searchEnv=flowEnv),
  compensatedParameter(parameters="FL2-H", spillRefId="SpillFromFCS", 
    transformationId=paste("FL2-H", "_compensated_according_to_FCS", sep=""), 
    searchEnv=flowEnv)
)
myEl@parameters <- new("parameters", compPars)
flowEnv[['myEl']] <- myEl
write.gatingML(flowEnv)
@

The \texttt{spillRefId="SpillFromFCS"} indicates that compensation according
to the description in the FCS data file shall used. In the Gating-ML output,
this will typically be described as \texttt{<gating:dimension
gating:compensation-ref="FCS">} for the appropriate dimensions.
If we wanted to use compensation based on a custom spillover (or spectrum) 
matrix instead, we could modify the code as follows: 

<<WriteGatingML3, echo=TRUE, eval=TRUE, results=hide>>=
spillM <- matrix(c(1, 0.03, 0.07, 1), nrow = 2, byrow=TRUE)
colnames(spillM) <- c("FL1-H", "FL2-H")
rownames(spillM) <- c("Comp-FL1-H", "Comp-FL2-H")
pars <- new("parameters", list("FL1-H", "FL2-H"))
myComp <- compensation(spillover=spillM, compensationId='spillM', pars)
flowEnv[['myComp']] <- myComp
compPars <- list(
  compensatedParameter(parameters="FL1-H", spillRefId="myComp", 
    transformationId="Comp-FL1-H", searchEnv=flowEnv),
  compensatedParameter(parameters="FL2-H", spillRefId="myComp", 
    transformationId="Comp-FL2-H", searchEnv=flowEnv)
)
myEl@parameters <- new("parameters", compPars)
flowEnv[['myEl']] <- myEl
write.gatingML(flowEnv)
@

Please note that new names are assigned to parameters compensated according to a
custom spillover matrix (\textit{i.e.}, \texttt{Comp-FL1-H} and
\texttt{Comp-FL2-H}).
This is necessary due to the generic Gating-ML 2.0 design, which also supports 
non-square spectrum matrices (where these is no one-to-one correspondence between 
the measured and ``compensated'' values). Should you wish to experiment with
non-square spectrum matrices, the following piece of code can be used to
generate one.

<<WriteGatingML4, echo=TRUE, eval=TRUE, results=hide>>=
flowEnv <- new.env()
specM <- matrix(c(0.78, 0.13, 0.22, 0.05, 0.57, 0.89), nrow = 2, byrow=TRUE)
colnames(specM) <- c("FL1-H", "FL2-H", "FL3-H")
rownames(specM) <- c("Deconvoluted-P1", "Deconvoluted-P2")
pars <- new("parameters", list("FL1-H", "FL2-H", "FL3-H"))
myComp <- compensation(spillover=specM, compensationId='specM', pars)
flowEnv[['myComp']] <- myComp
compPars <- list(
  compensatedParameter(parameters="FL1-H", spillRefId="myComp", 
    transformationId="Deconvoluted-P1", searchEnv=flowEnv),
  compensatedParameter(parameters="FL2-H", spillRefId="myComp", 
    transformationId="Deconvoluted-P2", searchEnv=flowEnv)
)
myEl@parameters <- new("parameters", compPars)
flowEnv[['myEl']] <- myEl
write.gatingML(flowEnv)
@



TODO Add example with transformation

TODO Add example with ratio

These were all examples of meaningful data transformations and analysis
pipelines that can be saved in a Gating-ML 2.0 file. Below, we demonstrate...

TODO

TODO Add example with unsupported transformation type

TODO

<<WriteGatingMLIssue1, echo=TRUE, eval=TRUE, results=verbatim>>=
logicle1 <- logicletGml2(parameters = "FL1-H", T = 1000, M = 4.5, A = 0, 
  transformationId="logicle1")
logicle2 <- logicletGml2(parameters = "logicle1", T = 1000, M = 4.5, A = 0, 
  transformationId="logicle2")
logicle2@parameters <- logicle1
myRect <- rectangleGate(filterId="myRect", list("logicle2"=c(0, .6)))
myRect@parameters <- new("parameters", list(logicle2))
flowEnv[['myRect']] <- myRect
x <- tryCatch(write.gatingML(flowEnv), error = function(e) { e })
# Just printing out x$message with a new line inserted so that the
# output does not run off the page in this vignetter
cat(paste(substr(x$message, 1, 74), substr(x$message, 75, nchar(x$message)), 
  sep = "\n"))
@

TODO show more examples of working stuff

TODO: explain compensation

TODO: explain asinh and ratio conversion.






\section{Testing Gating-ML compliance}
<<TestGatingMLCompliance, eval=FALSE, echo=TRUE, results=verbatim>>=
testGatingMLCompliance("ComplianceReport1.5", version=1.5)
testGatingMLCompliance("ComplianceReport2.0", version=2.0)
@

\section{Using Gating-ML to exchange gates with other software tools}
To the best of our knowledge, R, FlowRepository and Cytobank are the first
Gating-ML compatible software tools. FlowJo (and other tools) also
implemented most of Gating-ML, but are still working on adjusting some of the data
transformations to make Gating-ML based gating properly interoperable.

\subsection{Implicit FCS transformations}
As mentioned in section \ref{sec:ApplyingGatingMLfiles}, the
\texttt{transformation=FALSE} option should be used when
applying Gating-ML 1.5, and
the \texttt{transformation=linearize-with-PnG-scaling} option when applying
Gating-ML 2.0. This is because Gating-ML 2.0 specifies that the
``channel-to-scale'' transformation shall be performed after reading the
``channel'' values from the FCS data file. The ``channel-to-scale''
transformation includes:
\begin{itemize}
\item The ``linearization'' of FCS parameters stored on log scale, \textit{i.e.,} 
with \$P$n$E values different from ``0,0''.
\item The ``correction'' for gain of FCS parameters stored
with \$P$n$G values different from ``1''.
\end{itemize}
The latter one means nothing more than the division of the parameter value by
the appropriate \$P$n$G value. According to our experience, in the majority of 
cases, there are no \$P$n$G values in the FCS data files, and if these are
present and different from ``1'', the data file has usually been produced by one
of the older instruments. Also, as this is just a linear transformation, 
it may be ignored by some analysis tools as data is scaled based on the 
size of the display with little meaning of the actual absolute expression
values. However, this details is significant for being able to exchange
gates using Gating-ML. 
Therefore, should you be working with data files with \$P$n$G values different
from ``1'', and should you observe compatibility issues with third party
software tools (gates of wrong sizes or in wrong positions), you may want to
try reading your data with the \texttt{transformation=linearize} option.

\subsection{Precision issues}

<<PrecisionIssuesDemo, echo=true, results=verbatim>>=
fcsFile  <- system.file("extdata/examples", "166889.fcs", 
    package = "gatingMLData")
gateFile <- system.file("extdata/examples", "GatingML2.0_Export_166889.xml", 
    package = "gatingMLData")
myFrame  <- read.FCS(fcsFile, transformation="linearize-with-PnG-scaling")
flowEnv  <- new.env()
read.gatingML(gateFile, flowEnv)
for (x in ls(flowEnv)) if (is(flowEnv[[x]], "filter")) {
    result <- filter(myFrame, flowEnv[[x]])
    print(summary(result))
}
ls(flowEnv)
@

\begin{figure}[ht]
\centering
\includegraphics[width=0.25\textwidth]{166889}
\end{figure}


% TODO Add more citations
\clearpage
\bibliographystyle{plainnat} 
\bibliography{flowUtilsRefs}

\end{document}
